Derivative of SkullSecurity Before you can make sense of assembly, you must first have a firm grasp of the foundations covered on this page. The majority of this information may be learned through studying C programming. If you find this information outdated or tedious, feel free to skip this section entirely. These topics will provide a brief overview of each component. If you want a more comprehensive explanation, you should consult a reference or the Internet. This is intended to be a short and dirty introduction. Hexadecimal To operate in assembly, you must be able to fluently read hexadecimal. The ability to mentally convert to decimal is not required, but the ability to perform basic arithmetic is. There are other ways to represent hex, but the two most prevalent are: 0x-prefixed, such as 0x1ef7 Postfixed with an h, for example 1ef7h The digits 0 through f represent the decimal values 0 through 15: 0 = 0 1 = 1 ... 9 = 9 a = 10 b = 11 c = 12 d = 13 e = 14 f = 15 To convert hex to decimal, multiply each digit with 160, 161, 162, etc., beginning with the rightmost. Hence, in the case of 0x1ef7, the conversion is as follows: (7 * 16 0 ) + (f * 16 1 ) + (e * 16 2 ) + (1 * 16 3 ) ) + (f * 16 ) + (e * 16 ) + (1 * 16 ) = (7 * 16 0 ) + (15 * 16 1 ) + (14 * 16 2 ) + (1 * 16 3 ) ) + (15 * 16 ) + (14 * 16 ) + (1 * 16 ) = (7 * 1) + (15 * 16) + (14 * 256) + (1 * 4096) = 7 + 240 + 3584 + 4096 = 7927 We have calculators so that we do not have to perform this task repeatedly. But, you should be familiar with the numbers 00 to FF (0 to 255), as they will appear frequently and you will spend considerable time looking them up. As we all know, binary is a numbering system consisting exclusively of 0s and 1s. The usage is essentially identical to hex, except that powers of 16 are replaced by powers of 2. (1 * 2 0 ) + (1 * 2 1 ) + (0 * 2 2 ) + (1 * 2 3 ) ) + (1 * 2 ) + (0 * 2 ) + (1 * 2 ) = (1 * 1) + (1 * 2) + (0 * 4) + (1 * 8) = 1 + 2 + 0 + 8 = 11 Conversion between decimal and binary is uncommon; conversion between hexadecimal and binary is significantly more prevalent. This translation is frequent due to its simplicity: every four binary digits are transformed to a single hex digit. Hence, it is sufficient to know the first 16 binary-to-hex conversions. 0x0 = 0000 0x1 = 0001 0x2 = 0010 0x3 = 0011 0x4 = 0100 0x5 = 0101 0x6 = 0110 0x7 = 0111 0x8 = 1000 0x9 = 1001 0xa = 1010 0xb = 1011 0xc = 1100 0xd = 1101 0xe = 1110 0xf = 1111 Take, for instance, the binary number 100101101001110. Add zeros to the front to make its length a multiple of four: 0100101101001110 Split it into 4-digit groups: 0100 1011 0100 1110 Examine each four-digit combination in the table: 0x4 0xb 0x4 0xe Put everything together 0x4b4e The opposite direction is even simpler, using 0x469e as an example. Separate the numerals: 0x4 0x6 0x9 0xe Convert each to binary according to the table: 0100 0110 1001 1110 The leading zeros on the first group can be eliminated when they are combined: 100011010011110 Datatypes A datatype refers to the partitioning of hexadecimal digits.